// Copyright (c) 2022 James Reid. All rights reserved.
//
// This source code file is licensed under the terms of the MIT license, a copy
// of which may be found in the LICENSE.md file in the root of this repository.  
// 
// For a template copy of the license see one of the following 3rd party sites:
//      - <https://opensource.org/licenses/MIT>
//      - <https://choosealicense.com/licenses/mit>
//      - <https://spdx.org/licenses/MIT>

// @ts-check

/**
 * @file NestedModule type declaration
 * @author James Reid
 */

// @body
/**
 * Module fragment type enum. Module fragment type will determine which icon 
 * will be rendered alongside the module link text in the nav (please see 
 * [here]{@tutorial template-modification} for more information).
 * 
 * @typedef {"namespace-module"|"module"|"file"|"method"} ModuleType
 * @property {"namespace-module"} - An auto-generated module which itself only 
 *      has other modules as children with no method members, and no 
 *      `@submodule` tagged file corresponding to its path in the src directory. 
 *      Generated by plugin when there is no `@submodule` tagged file at the 
 *      given path. For example a `@submodule` tagged file at `path/to/file.js` 
 *      will cause a namespace module to be generated with the name `path`, 
 *      assuming that there are no `@submodule` tagged files in the `path` 
 *      directory (a `@submodule` tagged file for example `path/index.js` would 
 *      prevent this, and cause a module to be generated instead)
 * @property {"module"} - A module which has both modules and methods as 
 *      children, or alternatively a `@submodule` tagged file which has child 
 *      modules on the same path and an ignored basename. Generated by plugin 
 *      when a `@submodule` tagged file has child modules and an ignored 
 *      basename, most commonly when the file is an index file. For example a 
 *      `@submodule` tagged file at `path/to/index.js` would create a module 
 *      fragment at the path `path/to` with child modules at 
 *      `path/to/child/file.js` and child files at `path/to/file.js`
 * @property {"file"} - A module which only has methods as its members (i.e. no 
 *      modules as children). For example a `@submodule` tagged file at 
 *      `path/to/file.js` would create a file fragment at the path 
 *      `path/to/file`
 * @property {"method"} - `Methods/members of jsdoc modules contained within 
 *      files. This fragment type has no children
 */

/**
 * @ignore
 * @enum {ModuleType}
 */
const MODULE_TYPE = /** @type {const} */ ({
    namespaceModule: "namespace-module",
    module: "module",
    file: "file",
    method: "method"
})

/**
 * Module fragment hierarchy enum. Module fragment hierarchy will determine 
 * how the module will be rendered in the nav (please see 
 * [here]{@tutorial template-modification} for more information). Note that 
 * "current module fragment" or equivalent phrases refers to the module whose 
 * page is currently open (`...module-<current-module>.html`), or in code the 
 * current nested module object in the parsed module tree.
 * 
 * @typedef {"selected"|"parent"|"child"|"sibling"|"hidden"} ModuleHierarchy
 * @property {"selected"} - The current selected module fragment - i.e. the link
 *      in the module nav whose page is currently open in the body
 * @property {"parent"} - Any module which is a parent, grandparent etc. (all 
 *      the way up to top-level root modules) of the currently selected module
 *      fragment
 * @property {"child"} - **Direct** children of the currently selected module 
 *      fragment (i.e. not including grandchildren etc.)
 * @property {"sibling"} - Modules which are siblings of the currently selected
 *      module fragment
 * @property {"hidden"} - Modules which are grandchildren (or deeper) of the
 *      currently selected module fragment, or children of any sibling or parent 
 *      module fragments (i.e. any module which is not on or a direct sibling of 
 *      the selected module path, and therefore should not be rendered in the 
 *      nav)
 */

/**
 * @ignore
 * @enum {ModuleHierarchy}
 */
let MODULE_HIERARCHY = /** @type {const} */ ({
    selected: "selected",
    parent: "parent",
    child: "child",
    sibling: "sibling",
    hidden: "hidden",
})

/**
 * Object format of data parsed from existing module nav element, each link in
 * the existing module nav element will produce one NestedModule object, which 
 * will be nested together with all other NestedModules through the 
 * NestedModule.children arrays to form a tree like structure which may be 
 * used to re-render the module nav reflective of src directory.
 * 
 * @summary Object format of data parsed from existing module nav element
 * @tutorial module-fragments
 * @typedef {object} NestedModule
 * @property {string} name - Basename of module or member etc.
 * @property {string} href - Link of module or member etc. as used in the jsdoc
 *      autogenerated output; all links are top level
 * @property {ModuleType} type - Type of fragment - i.e. a submodule/file/method 
 *      contained within a submodule file
 * @property {ModuleHierarchy} hierarchy - Relative path relation to current 
 *      selected submodule (i.e. child, sibling, parent etc.), used to determine 
 *      how this submodule should be rendered (hidden, nested right etc.)
 * @property {string} path - Pathname of module or member etc. (dirname 
 *      concatenated with basename if basename exists)
 * @property {NestedModule[]} children - Array of submodules which are children
 *      of this given submodule
 * @property {string} [access] - Access of member if it is a method
 * @property {string} [scope] - Scope of member if it is a method
 */

// @exports
export { MODULE_TYPE, MODULE_HIERARCHY }

/**
 * @ignore
 * @type {NestedModule} 
 */
export let NestedModule