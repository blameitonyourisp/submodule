// Copyright (c) 2022 James Reid. All rights reserved.
//
// This source code file is licensed under the terms of the MIT license, a copy
// of which may be found in the LICENSE.md file in the root of this repository.  
// 
// For a template copy of the license see one of the following 3rd party sites:
//      * <https://opensource.org/licenses/MIT>
//      * <https://choosealicense.com/licenses/mit>
//      * <https://spdx.org/licenses/MIT>

// @ts-check

// @import-module
import { onTagged } from "./onTagged.js"
// @import-types
import { describe, test, expect } from "@jest/globals"

// @body
describe("onTagged", () => {
    // default sample of the required fragment of the jsdoc config from the cli
    const defaultEnv = {
        pwd: process.cwd(),
        conf: {
            submodule: {
                roots: {
                    "A": "src/submoduleA",
                    "B": "src/submoduleB",
                    "nestB": "src/submoduleB/nested"
                }
            },
            source: { include: ["src"] }
        }
    }

    // default sample of required fragment of the jsdoc doclet passed to the 
    // onTagged handler
    const defaultDoclet = { meta: { 
        path: "src/submoduleA", 
        filename: "feature.js" 
    }}

    /**
     * Mock fragment of doclet which should be generated by onTagged function
     * 
     * @template T
     * @param {T} doclet - existing doclet fragment usually initialized with a 
     *      fragment of the doclet.meta object created by jsdoc
     * @param {string} name - expected path/name of created module
     * @returns {T|{kind: string, name: string}}
     */
    const getDoclet = (doclet, name) => {
        return { ...doclet, kind: "module", name }
    }

    /**
     * Mock fragment of jsdoc tag required by onTagged function
     *
     * @param {?string} name - optional custom name provided in submodule tag
     * @returns {{value: {name: string}}|{}}
     */
    const getTag = (name = null) => { 
        return name ? { value: { name } } : {}
    }

    // standard case with no plugin configuration in the jsdoc json config file
    test("standard no config", () => {
        const env = {
            pwd: process.cwd(),
            conf: { source: { include: ["src"] } }
        }
        const doclet = { meta: { 
            path: "src/path/to",
            filename: "file.js"
        }}
        const name = "path/to/file"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // standard case with no resolution to a user declared root module path
    test("standard no resolution", () => {
        const env = defaultEnv
        const doclet = { meta: { 
            path: "src/path/to",
            filename: "file.js"
        }}
        const name = "path/to/file"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // standard case including a resolution to a user declared root module path
    test("standard with resolution", () => {
        const env = defaultEnv
        const doclet = { meta: { ...defaultDoclet.meta } }        
        const name = "A/feature"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // standard case with the default ignored "index" filename
    test("standard with ignored basename", () => {
        const env = defaultEnv
        const doclet = { meta: { 
            path: "src/submoduleB",
            filename: "index.js"
        }}
        const name = "B"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // explicit module name used with submodule tag should override the module 
    // name which would otherwise be generated
    test("explicit module name", () => {
        const env = defaultEnv
        const doclet = { meta: { ...defaultDoclet.meta } }
        const name = "explicit/module/name"
        onTagged.call(env, doclet, getTag(name))
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // no custom root modules declared in the submodule property of the jsdoc
    // config
    test("no submodule roots", () => {
        const env = { ...defaultEnv, conf: {
            ...defaultEnv.conf,
            submodule: {} 
        }}
        const doclet = { meta: { ...defaultDoclet.meta } }
        const name = "submoduleA/feature"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // custom ignore filenames declared in the submodule property of the jsdoc
    // config
    test("custom submodule ignore", () => {
        const env = { ...defaultEnv, conf: {
            ...defaultEnv.conf,
            submodule: {
                ...defaultEnv.conf.submodule,
                ignore: [ "custom" ]
            } 
        }}
        // case A testing the custom declared filename(s) to ignore
        let doclet = { meta: { 
            path: "src/submoduleA",
            filename: "custom.js"
        }}
        let name = "A"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
        // case B testing that the default ignored filename "index" is no longer
        // ignored
        doclet = { meta: { 
            path: "src/submoduleB",
            filename: "index.js"
        }}
        name = "B/index"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // multiple sources declared as includes in the jsdoc config
    test("multiple jsdoc source includes", () => {
        const env = { ...defaultEnv, conf: {
            ...defaultEnv.conf,
            submodule: {
                roots: {
                    "A": "srcA/submoduleA",
                    "B": "srcB/submoduleB",
                }
            },
            source: { include: ["srcA", "srcB"] }
        }}
        // case A testing the first include and its custom root modules
        let doclet = { meta: { 
            path: "srcA/submoduleA",
            filename: "feature.js"
        }}
        let name = "A/feature"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
        // case B testing the second include and its custom root modules
        doclet = { meta: { 
            path: "srcB/submoduleB",
            filename: "feature.js"
        }}
        name = "B/feature"
        onTagged.call(env, doclet, getTag())
        expect(doclet).toEqual(getDoclet(doclet, name))
    })

    // test file marked as a leafmodule file which should be documented under
    // the namespace module of the directory, and should set the "SUBMODULE"
    // environment variable
    test("leafmodule", () => {
        const env = { ...defaultEnv, leaf: true }
        const doclet = { meta: { 
            path: "src/path/to",
            filename: "file.js"
        }}
        // case A testing leafmodule in standard configuration
        const name = "path/to"
        onTagged.call(env, doclet, getTag())
        expect(process.env.SUBMODULE).toBe(name)
        // case B testing leafmodule with a custom module nam
        const customName = "custom/leafmodule/name"
        onTagged.call(env, doclet, getTag(customName))
        expect(process.env.SUBMODULE).toBe(customName)
    })
})