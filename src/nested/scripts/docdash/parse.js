// Copyright (c) 2022 James Reid. All rights reserved.
//
// This source code file is licensed under the terms of the MIT license, a copy
// of which may be found in the LICENSE.md file in the root of this repository.  
// 
// For a template copy of the license see one of the following 3rd party sites:
//      * <https://opensource.org/licenses/MIT>
//      * <https://choosealicense.com/licenses/mit>
//      * <https://spdx.org/licenses/MIT>

/**
 * @file Method for parsing modules from the docdash DOM into a nested module
 *      tree object for later re-render.
 * @module docdash/parse
 * @author James Reid
 */

// @ts-check

// @imports-types
import { NestedModule } from "../../types/index.js"
// @imports-local
import {
    methodRegex,
    childPathRegex,
    siblingPathRegex,
    methodSignatureRegex,
    absolutePath
} from "../shared/index.js"

// @body
/**
 * Parses existing nav into a nested structure for re-render by nesting modules
 * according to their pathname (i.e. "folder/subdirectory" would be nested 
 * underneath a top level module named "folder")
 * 
 * Apart from some DOM manipulation which is specific to docdash, much of the 
 * logic below could be shared with other templates when they are added.
 * 
 * @summary Parses existing nav into a nested structure for re-render
 * @param {HTMLUListElement} navList - Original modules nav list
 * @returns {NestedModule[]}
 */
const parseModules = navList => {
    /** 
     * Declare array to be returned - will be populated with top level modules
     * @type {NestedModule[]} 
     */
    const moduleTree = []

    // Loop over list elements contained within the original navList 
    for (const childNode of navList.querySelectorAll(":scope > li")) {
        // if multiple files share a module name, autogenerated docs will spawn
        // extra empty lists for each file, ignore these empty lists
        if (!childNode.firstChild) { continue }
        
        // fetch relevant data from childNode - note that the links nested in by
        // one level in the docdash template are always methods which are 
        // members of the given module
        const link = /** @type {HTMLLinkElement} */ 
            (childNode.querySelector(":scope > a")) 
        const methods = /** @type {NodeListOf<HTMLLinkElement>} */
            (childNode.querySelectorAll(":scope > ul > li > a")) 
        const splitPath = link.innerHTML.split("/")
        const [last, init] = [ 
            /** @type {string} */ (splitPath.pop()), 
            splitPath 
        ]

        // isolate "first-parent" scope of childNode within moduleTree - if the
        // scope does not yet exist, add it on the fly 
        let scope = moduleTree
        let scopePath = ""
        for (const name of init) {
            let inner = scope.find(obj => obj.name === name)
            if (!inner) {
                inner = getFragment({ name, link, scopePath })
                scope.push(inner)
            }
            scope = inner.children
            scopePath = inner.path
        }

        // look for existing module fragment with the same final basename - this
        // is for accounting for the "ignored" filename (default index.js) which
        // could be parsed after sibling modules if jsdoc is not generated with
        // sort option set to true in config -> i.e. given two files 
        // "src/path/feature.js" (module name "src/path/feature") and
        // "src/path/index.js" (module name "src/path"), the feature module will
        // be parsed first
        const inner = scope.find(obj => obj.name === last)
        if (inner) { 
            // case where fragment with same basename exists and existing
            // fragment must be updated
            Object.assign(inner, { type: "module", href: link.href })
            for (const link of methods) {
                inner.children.push(getFragment({ 
                    name: link.innerHTML, 
                    link, 
                    scopePath: inner.path
                }))
            }
        }
        else { 
            // case where fragment with same basename does not exist and a new
            // fragment must be created
            const children = []
            for (const link of methods) {
                children.push(getFragment({ 
                    name: link.innerHTML, 
                    link, 
                    scopePath: `${scopePath}_${last}`
                }))
            }
            scope.push(getFragment({ name: last, link, scopePath, children }))
        }        
    }

    // sort entire module tree as last step, ensuring that final rendered
    // nested nav will reflect more closely the hierarchy of src directory
    sortModuleTree(moduleTree)
    return moduleTree
}

/**
 * Recursively sort nested module tree **in place** such that all nested modules
 * have been sorted - {@link module:docdash/parse~getPriority see here} for 
 * function used in sorting.
 * 
 * @summary Recursively sort nested module tree
 * @param {NestedModule[]} moduleTree - Module tree to be sorted
 * @returns {void}
 */
const sortModuleTree = moduleTree => {
    // end if no children, otherwise recurse function for all children and sort
    // current array in place
    if (!moduleTree.length) { return }
    for (const { children } of moduleTree) { sortModuleTree(children) }
    moduleTree.sort((optA, optB) => getPriority(optA, optB))
}

/**
 * Get priority between two given nested module for which should appear first
 * in the nested module nav. Modules are ordered as follows with priority
 * decreasing down the list (i.e. first by type, last by alphabetical), please 
 * refer do documentation of each priority function for further details:
 *  1. Order by type - {@link module:docdash/parse~getTypePriority getTypePriority}
 *  2. Order by method signature scope - {@link module:docdash/parse~getSignaturePriority getSignaturePriority}
 *  3. Order by method signature access - {@link module:docdash/parse~getSignaturePriority getSignaturePriority}
 *  4. Order in ascending alphabetical order - {@link module:docdash/parse~getAlphabeticalPriority getAlphabeticalPriority}
 * 
 * @summary Get absolute priority between two nested modules
 * @param {NestedModule} optA - First nested module
 * @param {NestedModule} optB - Second nested module
 * @returns {number}
 */
const getPriority = (optA, optB) => {
    // add priorities together, bit shifting according to priority importance
    // to ensure that more significant priorities always take precedence
    return (getTypePriority(optA, optB) << 3) 
        + (getSignaturePriority(optA, optB, "scope") << 2) 
        + (getSignaturePriority(optA, optB, "access") << 1) 
        + getAlphabeticalPriority(optA, optB)
}

/**
 * Get type priority between two nested modules, ordering folder types ("module"
 * and "nested-module") above methods contained in a file in the same submodule.
 * 
 * @summary Get type priority between two nested modules
 * @param {NestedModule} optA - First nested module 
 * @param {NestedModule} optB - Second nested module 
 * @returns {number}
 */
const getTypePriority = (optA, optB) => {
    return optA.type === "method" && optB.type != "method" ? 1
        : optA.type != "method" && optB.type === "method" ? - 1
        : 0
}

/**
 * Get signature priority (either access or scope priority as specified in 
 * arguments), ordering from least to most "restrictive" as listed by jsdoc, a
 * summary of which may be found {@link https://github.com/blameitonyourisp/funky#standard here}.
 * 
 * @summary Get signature priority between two nested modules
 * @param {NestedModule} optA - First nested module 
 * @param {NestedModule} optB - Second nested module 
 * @param {"access"|"scope"} key - switch for sorting access or scope priority
 * @returns {number}
 */
const getSignaturePriority = (optA, optB, key) => {
    const order = key === "access"
        ? ["public", "package", "protected", "private"]
        : ["global", "instance", "static", "inner"]
    // if not found, indexOf will return -1, therefore if both not found return
    // will be 0
    return (order.indexOf(optA[key] || "") - order.indexOf(optB[key] || "")) % 2
}

/**
 * Get alphabetical priority between two nested modules, by ordering in 
 * ascending alphabetical order (A -> Z).
 * 
 * @summary Get alphabetical priority between two nested modules
 * @param {NestedModule} optA - First nested module
 * @param {NestedModule} optB - Second nested module 
 * @returns {number}
 */
const getAlphabeticalPriority = (optA, optB) => {
    return optA.name.localeCompare(optB.name) % 2
}

/**
 * Calculate node/fragment of nested module from arguments extracted from DOM -
 * determine type, hierarchy, path, href, and optionally access and scope of 
 * fragment.
 * 
 * @summary Get fragment of nested module nav structure
 * @param {object} argObj 
 * @param {string} argObj.name - basename of fragment
 * @param {HTMLLinkElement} argObj.link - link element from original module nav
 * @param {string} argObj.scopePath - dirname of fragment
 * @param {NestedModule[]} [argObj.children=[]] - existing children
 * @returns {NestedModule}
 */
const getFragment = ({ name, link, scopePath, children = [] }) => {
    // fetch href from the html link element and calculate full path of fragment
    const { href } = link
    const path = `${scopePath}_${name}`

    // fragment type; namespace-module for nested modules which do not have any
    // document members in the code
    const type = methodRegex.test(href) ? "method"
        : children.length ? "module" 
        : "namespace-module"

    // fragment hierarchy corresponds if fragment is a child, sibling etc.
    // according to fragment path and the current window location href
    const hierarchy = absolutePath === path ? "selected"
        : absolutePath.includes(path) ? "parent"
        : childPathRegex.test(path) ? "child"
        : type != "method" && siblingPathRegex.test(path) ? "sibling"
        : "hidden"

    // if fragment is a method then fetch access and scope from page, otherwise
    // return with no access or scope
    if (type === "method" && hierarchy === "child") {
        // find doclet element in page corresponding method name in nav
        const [id] = /** @type {string[]} */ (href.match(/(?<=\.html#).*$/))
        const method = /** @type {HTMLElement} */ (document.getElementById(id))
        
        // fetch access and scope values from doclet using regex
        let { access, scope } = /** @type {Object.<string, string>} */ (method
            .querySelector(":scope > span")
            ?.innerHTML
            .match(methodSignatureRegex)
            ?.groups)

        // set defaults if capture group(s) not populated (if the method has
        // public access and or instance scope, it will not be rendered in page)
        access ??= "public"
        scope ??= "instance"

        return { name, href, type, hierarchy, path, children, access, scope }
    }
    else {
        return { name, href, type, hierarchy, path, children }
    }
}

// @exports
export { parseModules }